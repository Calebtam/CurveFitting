#!/usr/bin/env python
PACKAGE = "dynamic_tutorials"
# 第一行非常简单，它们只是初始化 ros 并导入参数生成器。
from dynamic_reconfigure.parameter_generator_catkin import *

# 现在我们有了一个生成器，我们可以开始定义参数了。 
gen = ParameterGenerator()

# add 函数将一个参数添加到参数列表中。这需要几个不同的点：
    # name -一个字符串，指定应存储此参数的名称
    # paramtype -定义存储值的类型，可以是 int_t、double_t、str_t 或 bool_t 中的任何一个
    # level -稍后将传递给动态重新配置回调的位掩码。调用回调时，已更改的参数的所有级别值都会进行“或”运算，并将结果值传递给回调。
    # description -描述参数的字符串
    # default -指定默认值
    # min -指定最小值（可选，不适用于字符串和布尔值）
    # max -指定最大值（可选，不适用于字符串和布尔值）

# 这些行只是定义了不同类型的更多参数。
gen.add("int_param",    int_t,    0, "An Integer parameter", 50,  0, 100)
gen.add("double_param", double_t, 0, "A double parameter",    .5, 0,   1)
gen.add("str_param",    str_t,    0, "A string parameter",  "Hello World")
gen.add("bool_param",   bool_t,   0, "A Boolean parameter",  True)


# 这里我们定义一个整数，其值由枚举设置。为此，我们调用 gen.enum 并向其传递一个常量列表，后跟枚举的描述。现在我们已经创建了一个枚举，我们现在可以将它传递给生成器。现在参数可以设置为“Small”或“Medium”，而不是 0 或 1。
size_enum = gen.enum([ gen.const("Small",      int_t, 0, "A small constant"),
                       gen.const("Medium",     int_t, 1, "A medium constant"),
                       gen.const("Large",      int_t, 2, "A large constant"),
                       gen.const("ExtraLarge", int_t, 3, "An extra large constant")],
                     "An enum to set size")

gen.add("size", int_t, 0, "A size parameter which is edited via an enum", 1, 0, 3, edit_method=size_enum)

# 最后一行只是告诉生成器生成必要的文件并退出程序。第二个参数是可以运行的节点的名称（仅用于生成文档），第三个参数是生成的文件将获得的名称前缀（例如，对于 c++ 为“<name>Config.h”，或“<name >Config.py”用于Python。
exit(gen.generate(PACKAGE, "dynamic_tutorials", "Tutorials"))

# https://wiki.ros.org/dynamic_reconfigure/Tutorials/HowToWriteYourFirstCfgFile

# Use the cfg File

# 为了使这个 cfg 文件可用，它必须是可执行的，所以让我们使用以下命令使其可执行
# chmod a+x cfg/Tutorials.cfg

# 接下来，我们需要将以下行添加到 CMakeLists.txt 中。对于 Groovy 及以上版本
# #add dynamic reconfigure api
# #find_package(catkin REQUIRED dynamic_reconfigure)
# generate_dynamic_reconfigure_options(
#   cfg/Tutorials.cfg
#   #...
# )

# # make sure configure headers are built before any node using them
# # 确保配置标头在任何节点使用它们之前构建
# add_dependencies(example_node ${PROJECT_NAME}_gencfg)

# 请注意，在到达 add_dependencies 行之前，您需要一个已构建的节点 example_node（参考在 C++ 中创建节点）。
# 这将在构建包时运行我们的 cfg。最后要做的事情是构建包，我们就完成了！